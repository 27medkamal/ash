<!-- livebook:{"persist_outputs":true} -->

# State Machines

```elixir
Mix.install(
  [
    {:ash, "~> 3.0.0-rc"},
    {:ash_state_machine, "~> 0.2.3-rc"},
    {:kino, "~> 0.12"}
  ],
  consolidate_protocols: false
)

# set to `:debug` if you'd like to see ETS logs
Logger.configure(level: :warning)
```

## State Machines

### Steps to define a state machine

* Add the `AshStateMachine` extension
* Add the `state_machine` DSL block
* Configure `state_machine.initial_states` to the allowed list of starting states
* Configure `state_machine.default_initial_state` to the default initial state
* Add the `state_machine.transitions` block
* Add transitions to the `state_machine.transitions` block.
* A transition consists of:
  * The action or `:*` to indicate any action
  * The `from` option, set to a state, list of states, or `:*` to indicate any state
  * The `to` option, set to a state, list of states, or `:*` to indicate any state
* Add or modify the actions mentioned in your transitions, to use `change transition_state/1` or `AshStateMachine.transition_state` to modify the state attribute

### Need more context?

See the [AshStateMachine Documentation](https://hexdocs.pm/ash_state_machine)

## Example

<!-- livebook:{"disable_formatting":true} -->

```elixir
defmodule Package do
  use Ash.Resource,
    domain: Domain,
    extensions: [AshStateMachine],
    data_layer: Ash.DataLayer.Ets

  state_machine do
    # all valid initial states
    initial_states [:awaiting_shipment]
    # the default initial state
    default_initial_state :awaiting_shipment

    # all valid state transitions
    transitions do
      transition :shipped, from: [:awaiting_shipment, :awaiting_return], to: :on_its_way
      transition :refused, from: :on_its_way, to: :awaiting_shipment
      transition :accepted, from: :on_its_way, to: :delivered
      transition :lost, from: [:on_its_way, :awaiting_return, :awaiting_shipment], to: :lost
    end
  end

  # Standard Ash Attributes
  attributes do
    uuid_primary_key :id
    attribute :from_address, :string, allow_nil?: false
    attribute :to_address, :string, allow_nil?: false
    attribute :refused?, :boolean, default: false
    attribute :got_signature?, :boolean
    attribute :lost_in_state, :atom do
      constraints one_of: [:on_its_way, :awaiting_return, :awaiting_shipment]
    end
  end

  actions do
    defaults [:read, create: [:from_address, :to_address]]

    update :shipped do
      # use `change transition_state/1` to set the state
      change transition_state(:on_its_way)
    end

    update :lost do
      # other updates can be made, in addition to modifying the state
      # Here, we set `lost_in_state` to the current state (before updating)
      change atomic_update(:lost_in_state, expr(state))
      change transition_state(:lost)
    end

    update :refused do
      # swap the from and to address
      change atomic_update(:from_address, expr(to_address))
      change atomic_update(:to_address, expr(from_address))

      # set an additional attribute values
      change set_attribute(:refused?, true)
      change transition_state(:awaiting_shipment)
    end

    update :accepted do
      accept [:got_signature?]
      change transition_state(:delivered)
    end
  end
end

defmodule Domain do
  use Ash.Domain,
    validate_config_inclusion?: false

  resources do
    resource Package do
      define :create_package, action: :create, args: [:from_address, :to_address]
      define :package_shipped, action: :shipped
      define :package_lost, action: :lost
      define :package_refused, action: :refused
      define :package_accepted, action: :accepted, args: [:got_signature?]
    end
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Domain, <<70, 79, 82, 49, 0, 3, 61, ...>>,
 [
   Ash.Domain.Dsl.Resources.Resource,
   Ash.Domain.Dsl.Resources.Options,
   Ash.Domain.Dsl,
   %{opts: [], entities: [...]},
   Ash.Domain.Dsl,
   Ash.Domain.Dsl.Resources.Options,
   ...
 ]}
```

## Use actions to move through states

```elixir
package = Domain.create_package!("my house", "your house")
```

<!-- livebook:{"output":true} -->

```
#Package<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "51d55836-dd79-4885-9fb0-409e027dc3ca",
  from_address: "my house",
  to_address: "your house",
  refused?: false,
  got_signature?: nil,
  lost_in_state: nil,
  state: :awaiting_shipment,
  aggregates: %{},
  calculations: %{},
  ...
>
```

```elixir
# do a valid transition
package = Domain.package_shipped!(package)
```

<!-- livebook:{"output":true} -->

```
#Package<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "51d55836-dd79-4885-9fb0-409e027dc3ca",
  from_address: "my house",
  to_address: "your house",
  refused?: false,
  got_signature?: nil,
  lost_in_state: nil,
  state: :on_its_way,
  aggregates: %{},
  calculations: %{},
  ...
>
```

```elixir
# try an invalid transition
Domain.package_shipped(package)
```

<!-- livebook:{"output":true} -->

```
{:error,
 %Ash.Error.Invalid{
   changeset: #Ash.Changeset<
     domain: Domain,
     action_type: :update,
     action: :shipped,
     attributes: %{},
     relationships: %{},
     errors: [
       %AshStateMachine.Errors.NoMatchingTransition{
         action: :shipped,
         target: :on_its_way,
         old_state: :on_its_way,
         splode: Ash.Error,
         bread_crumbs: [],
         vars: [],
         path: [],
         stacktrace: #Splode.Stacktrace<>,
         class: :invalid
       }
     ],
     data: #Package<
       __meta__: #Ecto.Schema.Metadata<:loaded>,
       id: "51d55836-dd79-4885-9fb0-409e027dc3ca",
       from_address: "my house",
       to_address: "your house",
       refused?: false,
       got_signature?: nil,
       lost_in_state: nil,
       state: :on_its_way,
       aggregates: %{},
       calculations: %{},
       ...
     >,
     context: %{state_machine: %{attempted_change: :on_its_way}},
     valid?: false
   >,
   query: nil,
   action_input: nil,
   errors: [
     %AshStateMachine.Errors.NoMatchingTransition{
       action: :shipped,
       target: :on_its_way,
       old_state: :on_its_way,
       splode: Ash.Error,
       bread_crumbs: [],
       vars: [],
       path: [],
       stacktrace: #Splode.Stacktrace<>,
       class: :invalid
     }
   ],
   splode: Ash.Error,
   bread_crumbs: [],
   vars: [],
   path: [],
   stacktrace: #Splode.Stacktrace<>,
   class: :invalid
 }}
```

```elixir
# notice how smart we can make our state machines using actions
# The from/to addresses were swapped, and `refused?` was set to true
package = Domain.package_refused!(package)
```

<!-- livebook:{"output":true} -->

```
#Package<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "51d55836-dd79-4885-9fb0-409e027dc3ca",
  from_address: "your house",
  to_address: "my house",
  refused?: true,
  got_signature?: nil,
  lost_in_state: nil,
  state: :awaiting_shipment,
  aggregates: %{},
  calculations: %{},
  ...
>
```

```elixir
# and now our package can finish its journey back to us!

package = Domain.package_shipped!(package)
Domain.package_accepted!(package, true)
```

<!-- livebook:{"output":true} -->

```
#Package<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "51d55836-dd79-4885-9fb0-409e027dc3ca",
  from_address: "your house",
  to_address: "my house",
  refused?: true,
  got_signature?: true,
  lost_in_state: nil,
  state: :delivered,
  aggregates: %{},
  calculations: %{},
  ...
>
```

## Introspection Examples

```elixir
# Generate charts (use `mix ash_state_machine.generate_flow_charts`)
Package
|> AshStateMachine.Charts.mermaid_flowchart()
|> Kino.Shorts.mermaid()
```

<!-- livebook:{"output":true} -->

```mermaid
flowchart TD
awaiting_shipment --> |shipped| on_its_way
on_its_way --> |refused| awaiting_shipment
on_its_way --> |accepted| delivered
on_its_way --> |lost| lost
awaiting_shipment --> |lost| lost
```

```elixir
# List all potential states
AshStateMachine.Info.state_machine_all_states(Package)
```

<!-- livebook:{"output":true} -->

```
[:awaiting_shipment, :awaiting_return, :on_its_way, :delivered, :lost]
```

```elixir
# See all state transitions
AshStateMachine.Info.state_machine_transitions(Package)
|> Enum.map(&Map.take(&1, [:action, :from, :to]))
```

<!-- livebook:{"output":true} -->

```
[
  %{from: [:awaiting_shipment, :awaiting_return], to: [:on_its_way], action: :shipped},
  %{from: [:on_its_way], to: [:awaiting_shipment], action: :refused},
  %{from: [:on_its_way], to: [:delivered], action: :accepted},
  %{from: [:on_its_way, :awaiting_return, :awaiting_shipment], to: [:lost], action: :lost}
]
```

```elixir
# See all state transitions for a given action
AshStateMachine.Info.state_machine_transitions(Package, :accepted)
```

<!-- livebook:{"output":true} -->

```
[
  %AshStateMachine.Transition{
    action: :accepted,
    from: [:on_its_way],
    to: [:delivered],
    __identifier__: -576460752303416382
  }
]
```
